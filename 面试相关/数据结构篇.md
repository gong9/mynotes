# 数据结构篇


<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.75; color: #595959; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center; user-select: auto;"><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; text-size-adjust: 100%; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; box-sizing: inherit; border-left: none; border: 1px solid #DEC6FB; background: #F6EEFF;"><span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;">❝</span>
<p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;">js篇没有结束喔，只不过先复习一下数据结构吧</p>
<p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;">前两天看到一个大佬发的关于数据结构的博客，满满的字一个代码没有，众人都说太干了。然后小白就写一个只实现的吧</p>
<p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;">注意只是实现只是实现喔，因为这几个简单的数据结构说实话好像也没有什么值得解释的，不像平衡树大小堆那种</p>
<p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;">希望你有一些数据结构的基础，了解他们的基本结构</p>
<p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;">图中的图片，一部分是自己画的，一部分是百度图片找的。原来在某c开头的博客上记录笔记故有了上面的水印。此篇是先实现简单的数据结构</p>
<p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;">函数式编程的下篇毁于掘金更新那段时间了，很痛心，希望后面忍着泪补上</p>
<p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;">希望与大家共同进步，代码过多难免有疏漏。如有误，望指教，感恩，如若嫌弃本文同样太干，可翻阅一下小白之间的笔记（上半年纯小白时写的放到文章最后了）</p>
<p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;">额，可能代码太长排不了版</p>
<span style="float: right; color: #DEC6FB;">❞</span></blockquote>
</section>




## 一、栈

![image.png](C:\Users\T540P\Desktop\img (2)\01.png)

一个栈的数据结构应实现一下功能



- push 出栈
- pop 入栈
- peek 返回栈顶元素
- isEmpty 判空
- clear 清除栈中元素
- size 返回栈中元素个数



实现及部分测试代码



```
 class Stack {
            constructor() {
                this._count = 0 //可记录栈内元素长度也可以当做栈内指针
                this._data = {} //用于存储栈内数据
            }
            isEmpty() {
                return this._count === 0
            }
            push(value) {
                this._data[this._count++] = value
            }
            pop() {
                if (this.isEmpty()) {
                    return undefined
                }
                this._count--;

                let res = this._data[this._count]
                delete this._data[this._count]

                return res
            }
            peek() {
                return this._data[this._count - 1]
            }
            size() {
                return this._count
            }
            clean() {
                this._data = {}
                this._count = 0
            }

        }

        const stack = new Stack()
        stack.push(5)
        stack.push(8)
        stack.push(10)

        console.log(stack.peek())
        console.log(stack.pop())
        console.log(stack)
        console.log(stack.size())
```



## 二、队列



### 2.1 普通队列

![image.png](C:\Users\T540P\Desktop\img (2)\02.png)



一个队列的数据结构要实现以下方法



- enqueue（e）向队尾添加元素
- dequeue() 从对头出去一个元素
- peek（）返回队列中的第一个元素，也即：返回对头元素
- isEmpty（）判空
- size（）返回队列中元素的个数
- clear() 清空



实现及部分测试代码



```
        class Queue {
            constructor() {
                this._data = {}
                this._count = 0
                this._first = 0 //队头指针
            }
            isEmpty() {
                return this._count === this._first
            }
            enqueue(value) {
                this._data[this._count++] = value
            }
            dequeue() {
                if (this.isEmpty()) {
                    return undefined
                }
                let res = this._data[this._first]
                delete this._data[this._first]
                this._first++;
                return res

            }
            peek() {
                if (this.isEmpty()) {
                    return undefined
                }
                return this._data[this._first]
            }
            size() {
                return this._count - this._first
            }
            clean() {
                this._data = {}
                this._count = 0
                this._first = 0
            }
        }
        const q = new Queue()
        q.enqueue(1)
        q.enqueue(2)
        q.enqueue(3)
        q.enqueue(4)
        console.log(q)
        console.log(q.dequeue())
        console.log(q.peek())
        console.log(q.size())
```



### 2.2 双端队列

![image.png](C:\Users\T540P\Desktop\img (2)\03.png)



一个双端队列的数据结构要实现以下功能



双端队列



- isEmpty
- clear
- size
- addFront（e） 队头添加元素
- addBack(e) 队尾添加元素
- removeFront 队头移出元素
- removeBack 队尾移出元素
- peekFront 取队头元素
- peekBack 取队尾元素



实现及部分测试代码



```
        class Deque {
            constructor() {
                this._data = {}
                this._count = 0
                this._first = 0
            }
            isEmpty() {
                    return this._count === this._first
                }
                //队尾进
            enqueue(value) {
                    this._data[this._count++] = value
                }
                //队头出
            dequeue() {
                    if (this.isEmpty()) {
                        return undefined
                    }
                    let res = this._data[this._first]
                    delete this._data[this._first]
                    this._first++;
                    return res

                }
                //队头进
            addFront(value) {
                    if (this.isEmpty()) {
                        this.enqueue(value)
                    }
                    this._data[--this._first] = value
                }
                //队尾出
            removeBack() {
                if (this.isEmpty()) {
                    return undefined
                }
                this._count--
                    let res = this._data[this._count]
                delete this._data[this._count]
                return res
            }
        }

        const d = new Deque()
        d.enqueue(1)
        d.enqueue(2)
        d.addFront(3)

        //    此时队列的数据从头到尾应是3,1,2
        //    调用队头出应是3
        console.log(d.dequeue())

        // 再掉队尾出应是2
        console.log(d.removeBack())
```



其他比较简单上面已有实现思路，就不一一重复了



### 2.3 循环队列

![image.png](C:\Users\T540P\Desktop\img (2)\04.png)



我们在这个循环队列数据结构中实现以下功能



- isEmpty 判空
- isFull 判满
- put（e）队尾插
- poll（）队头取



实现及部分测试代码



```
        class SqQueue {
            constructor() {
                this._data = {}
                this._front = 1 //头部指针
                this._rear = 1 //尾部指针
                this.MAX = 5
            }
            isEmpty() {
                return this._front === this._rear
            }
            isFull() {
                return (this._rear + 1) % this.MAX === this._front
            }
            put(value) {
                if (this.isFull()) {
                    return 'FULL'
                }
                this._data[this._rear] = value

                // 指针后移的同时也要考虑它是个环不能允许它超过最大值
                //即如果此时它在5的位置，假设此时头在2或3等位置未满，那么尾指针后移应该1而不能是6
                this._rear = (this._rear + 1) % this.MAX
            }
            poll() {
                if (this.isEmpty()) {
                    return undefined
                }
                let res = this._data[this._front]
                delete this._data[this._front]
                this._front = (this._front + 1) % this.MAX
                return res
            }
        }
        let sq = new SqQueue()
        sq.put(1)
        sq.put(2)
        sq.put(3)
        sq.put(4)
        console.log(sq.poll()) //1
        console.log(sq.poll()) //2
        console.log(sq.poll()) //3
        sq.put(2)
        sq.put(3)
        sq.put(4)

        // 此时从队尾 - > 队头应是4, 3, 2, 4
        console.log(sq.poll()) //4
        console.log(sq.poll()) //2
        console.log(sq.poll()) //3
        console.log(sq.poll()) //4
```



## 三、链表



![image](C:\Users\T540P\Desktop\img (2)\05.png)



### 3.1 单链表



节点类



```
  class LNode {
            constructor(value) {
                this._value = value
                this._next = null //指针域
            }
        }
```



链表类



```
  //单链表类
        class LinkList {
            constructor() {
                this._head = null //头节点
                this._count = 0
            }
        }
```



我们接下来实现以下方法



- push(element) 向尾部插一个
- insert(element, position) 向指定位置插一个
- getElementAt(index) 获取指定位置的元素
- remove(element) 移出元素
- indexOf(element) 返回该元素的位置
- removeAt(position) 移出指定位置的元素
- isEmpty() 判空
- size() 链表长度



#### push



```
 push(value) {
                const node = new LNode(value)
                let current = this._head

                if (current === null) {
                    this._head = node
                } else {
                    // 不是空，顺着链条向下找,最后一个节点的指针域为空
                    while (current._next) {
                        current = current._next
                    }
                    current._next = node
                }

                this._count++
            }



//最后的测试代码

      const l = new LinkList()
        l.push(1)
        l.push(2)
        l.push(3)
        l.push(4)
        console.log(l)
```





#### getElementAt及insert



这俩在一起写的是因为，我们可以在insert方法中借用一下getElementAt



```
  // 获取指定位置的节点
            getElementAt(index) {
                if (!(index >= 0 && index < this._count)) return undefined
                let current = this._head
                for (let i = 0; i < index; i++) {
                    current = current._next
                }
                return current

            }

            // 在任意位置插入
            insert(value, index) {
                if (!(index >= 0 && index <= this._count)) return undefined

                const node = new LNode(value)
                    // index==0
                if (index === 0) {
                    let current = this._head
                    this._head = node
                    this._head._next = current
                } else {
                    // 还是先找要操作的前一位置
                    let pre = this.getElementAt(index - 1)
                    let current = pre._next

                    pre._next = node
                    node._next = current

                }
                this._count++;

            }


//最后的测试代码
       l.push(1)
        l.push(2)
        l.push(3)
        l.push(4)
        l.insert(5, 1)
        console.log(l)
```



可以看到5被查到index=1的位置了（从0开始的）





#### removeAt



```
// 移出指定位置的节点
                      removeAt(index) {
                if (!(index >= 0 && index < this._count)) return undefined
                let current = this._head
                if (index === 0) {
                    this._head = current._next
                } else {
                    let previous;
                    for (let i = 0; i < index - 1; i++) {
                        current = current._next
                    }
                    previous = current //指向要删除节点的前一个
                    current = current._next //指向当前要删除节点
                    previous._next = current._next


                    return current._value
                }
                this._count--


            }
//最后的测试代码
        const l = new LinkList()
        l.push(1)
        l.push(2)
        l.push(3)
        l.push(4)
        l.insert(5, 1)
        l.removeAt(1)
        console.log(l)

```



可以看到上面刚插入的5又被移出了





#### indexOf



```
 //返回指定节点元素的位置
            indexOf(value) {
                let current = this._head
                    //遍历一下链表即可
                for (let i = 0; i < this._count && current != null; i++) {
                    if (current._value === value) {
                        return i
                    } else {
                        current = current._next
                    }
                }
            }

//最后的测试代码
const l = new LinkList()
        l.push(1)
        l.push(2)
        l.push(3)
        l.push(4)
        l.insert(5, 1)
        l.removeAt(1)
        console.log(l.indexOf(3));
        console.log(l)

```





#### remove



```
  // 移出一个指定元素的节点
            remove(value) {
                let index = this.indexOf(value)
                this.removeAt(index)
            }

```





#### isEmpty及size()



```
 //链表长度
            size() {
                return this._count
            }

            // 判空
            isEmpty() {
                return this.size() === 0
            }

```



### 3.2 双向链表

![image.png](C:\Users\T540P\Desktop\img (2)\06.png)

```
         class Node {
            constructor(value) {
                this.value = value
                this.pre = null //前驱指针
                this.next = null //后继指针
            }
        }

        class DoubleLinkedList {
            constructor() {
                this.count = 0
                this.head = null
                this.q = null //指向尾节点
            }

            //根据位置返节点
            getElementAt(index) {
                if (index < 0 || index >= this.count) return undefined
                let current = this.head
                for (let i = 0; i < index; i++) {
                    current = current.next
                }
                return current
            }

            //指定位置插入
            insert(value, index) {
                if (index < 0 || index > this.count) return false
                const node = new Node(value)

                // 解析考虑三种情况，在头、在尾、在中间

                //头
                if (index === 0) {
                    // 又分为链表开始为空与不空
                    if (this.head === null) {
                        this.head = node
                        this.q = node
                    } else {
                        node.next = this.head
                        this.head.pre = node
                        this.head = node
                    }

                }

                // 尾部
                else if (index === this.count) {
                    this.q.next = node
                    node.pre = this.q

                    // 再让q指回尾部
                    this.q = node
                }
                // 中间
                else {
                    // 和单链表的操作一样，找到要操作的前一个
                    let pre = this.getElementAt(index - 1)
                    let current = pre.next

                    pre.next = node
                    node.next = current

                    node.pre = pre
                    current.pre = node
                }
                this.count++

            }

            // 指定位置移出
            removeAt(index) {
                if (index < 0 || index >= this.count)
                    return false

                // 处理情况也分为在头在尾在中间

                // 头
                if (index === 0) {
                    this.head = this.head.next

                    // 不能马上将前驱指针设为null，不能保证有没有第二个节点
                    if (this.count === 1) {
                        this.q = null
                    } else {

                        this.head.pre = null
                    }
                }

                //尾
                else if (index == this.count - 1) {
                    let current = this.q.pre
                    current.next = null
                    this.q = current
                }

                // 中间
                else {
                    // 还是先找它的前一个
                    let preNode = getElementAt(index - 1)
                    let current = preNode.next

                    preNode.next = current.next
                    current.next.pre = preNode
                }

                this.count--

            }
        }

        const test = new DoubleLinkedList();
        test.insert(1, 0)
        test.insert(2, 1)
        test.insert(3, 2)
        test.insert(4, 3)
        test.removeAt(3)
        console.log(test)

```

![image.png](C:\Users\T540P\Desktop\img (2)\07.png)



### 3.3 循环链表

![image.png](C:\Users\T540P\Desktop\img (2)\08.png)





上面实现了双向链表，而循环链表则是对链表的进一步改进。使得它们可以头连尾，尾连头。构成一个闭环。

同样，它的很多操作是和单链表是一样的。在这我们只看它们任意位置插入和任意位置删除两个方法

#### **insert**

```
 class Node {
            constructor(value) {
                this.value = value
                this.pre = null //前驱指针
                this.next = null //后继指针
            }
        }

        class LinkedList {
            constructor() {
                    this.count = 0
                    this.head = null
                    this.q = null //指向尾节点
                }
                //根据位置返节点
            getElementAt(index) {
                if (index < 0 || index >= this.count) return undefined
                let current = this.head
                for (let i = 0; i < index; i++) {
                    current = current.next
                }
                return current
            }

            insert(value, index) {
                if (index < 0 || index > this.count) return false
                const node = new Node(value)

                // 头
                if (index === 0) {
                    if (this.head === null) {
                        this.head = node
                        this.q = node

                        node.pre = node
                        node.next = node
                    } else {
                        node.next = this.head
                        this.head.pre = node
                        this.head = node

                        this.head.pre = this.q
                        this.q.next = this.head
                    }
                }
                // 尾
                else if (index == this.count) {
                    this.q.next = node
                    node.pre = this.q
                    this.q = node
                    this.q.next = this.head
                    this.head.pre = this.q
                }
                // 中间
                else {
                    // 和原来一样
                    let preNode = this.getElementAt(index - 1)
                    let current = preNode.next

                    preNode.next = node
                    node.pre = preNode
                    current.pre = node
                    node.next = current

                }
                this.count++

            }
        }
const test = new LinkedList()
        test.insert(1, 0)
        test.insert(2, 1)
        test.insert(3, 2)

        console.log(test)

```

**1-2-3-1-2-3，最后的指针又指回了第一个节点实现循环**

**![image.png](C:\Users\T540P\Desktop\img (2)\09.png)**

#### **removeAt**

```
remove(index) {
                if (index < 0 || index > this.count - 1) return false

                // 头
                if (index === 0) {

                    // 又分只有一个元素和多个
                    if (this.count === 1) {
                        this.head = null
                        this.q = null
                    } else {
                        this.head = this.head.next
                        this.head.pre = this.q
                        this.q.next = this.head
                    }

                }
                // 尾
                else if (index === this.count - 1) {
                    let current = this.q.pre
                    this.q = current
                    this.q.next = this.head
                    this.head.pre = this.q
                }
                // 中间
                else {
                    // 和原来一样，取到前一个
                    let preNode = this.getElementAt(index - 1)
                    let current = preNode.next

                    preNode.next = current.next
                    current.next.pre = preNode

                }
                this.count--

            }


//最后的测试

```

**看图删掉之后上一个是3，下个也是3**

**![image.png](C:\Users\T540P\Desktop\img (2)\10.png)**

## 四、集合、字典、哈希表



### 4.1 集合

![image.png](C:\Users\T540P\Desktop\img (2)\11.png)

这里的集合基本和数学中的集合一致

可这么理解：它就由一组无序其唯一的项组成（这不就是set吗？）

#### 集合的实现



开始实现，还是用对象作为存储数据的容器（容易保证唯一）



一个集合的数据结构通常有以下方法

- add(element)：向集合添加一个新元素。
- delete(element)：从集合移除一个元素。
- has(element)：如果元素在集合中，返回 true，否则返回 false。
- clear()：移除集合中的所有元素。
- size()：返回集合所包含元素的数量。它与数组的 length 属性类似。
- values()：返回一个包含集合中所有值（元素）的数组



**比较简单直接看实现代码**

```
 class Set {
            constructor() {
                this.container = {}
            }
            has(value) {
                return value in this.container
            }
            add(value) {
                if (this.has(value)) return false
                this.container[value] = value
            }
            delete(value) {
                if (!this.has(value)) return false
                delete this.container[value]
            }
            clear() {
                this.container = {}
            }
            size() {
                return Object.keys(this.container).length
            }
            value(){
                return Object.values(this.container)
            }
        }

```

#### 集合的运算

我们要实现以下运算

- 并集
- 交集
- 差集
- 子集

##### 并集

![image.png](C:\Users\T540P\Desktop\img (2)\12.png)

实现思路：把创建一个新集合，将集合a和集合b的数据放进去

```
        function union(set01, set02) {
            const newSet = new Set()
            set01.value().forEach(item => newSet.add(item))
            set02.value().forEach(item => newSet.add(item))
            return newSet
        }

```

##### 交集

![image.png](C:\Users\T540P\Desktop\img (2)\13.png)

实现思路，还是借用一个新集合。然后随便拿一个a或b的数据进行操作，遍历操作时发现对方也有此数据就放到新集合

```
function intersection(set01, set02) {
            const newSet = new Set()
            set01.value().forEach(item => {
                if (set02.has(item)) {
                    newSet.add(item)
                }
            })
            return newSet
        }

```

##### 差集A-B

![image.png](C:\Users\T540P\Desktop\img (2)\14.png)

实现思路：借助一个新集合，遍历a集合数据时，判断b中有无，有就剔除

```
        function difference(set01, set02) {
            const newSet = new Set()
            set01.value().forEach(item => {
                if (!set02.has(item)) {
                    newSet.add(item)
                }
            })
        }

```

##### 子集

![image.png](C:\Users\T540P\Desktop\img (2)\15.png)

我们主要实现的方法是判断一个集合是否是另一个集合的子集



实现思路：如判断a集合是否是b集合的子集，我们要做的就是看a集合的所有元素是不是b中都有

```
       function isSubsetOf(a, b) {
            if (a.size() > b.size()) return false

            let flag = a.value().every(item => {
                return b.has(item)
            })

            return flag
        }

```



### 4.2 字典

上面我们实现了集合，知道集合就是存放了一组互不重复的元素。字典和它相差不多，只不过集合里面只是保存了值，而在这里是以键值对的方式保存的 



我们接下来要实现以下功能



- set(key,value)：向字典中添加新元素。如果 key 已经存在，那么已存在的 value 会被新的值覆盖
- remove(key)：通过使用键作为参数来从字典中移除键值对应的数据值。
- hasKey(key)：如果某个键值存在于该字典中，返回 true，否则返回 false。
- get(key)：通过以键值作为参数查找特定的数值并返回。
- clear()：删除该字典中的所有值。
- isEmpty()：在 size 等于零的时候返回 true，否则返回 false。
- keys()：将字典所包含的所有键名以数组形式返回。
- values()：将字典所包含的所有数值以数组形式返回。
- keyValues()：将字典中所有[键，值]对返回。
- forEach(callbackFn)：迭代字典中所有的键值对。 callbackFn 有两个参数： key 和value。



这里都比较简单就直接上代码吧(简单的自己也没有怎么写测试代码，看思路就完事了)

```
        class Dictionary {
            constructor() {
                this.container = {}
            }

            // 根据指定键，判字典中有无
            hasKey(key) {
                return key in this.container
            }
            set(key, value) {
                if (key !== null && value !== null) {
                    this.container[key] = value
                }
            }
            remove(key) {
                if (this.hasKey(key)) {
                    delete this.container[key]

                }
            }
            get(key) {
                if (this.hasKey(key)) {
                    return this.container[key]
                } else {
                    return undefined
                }
            }
            keys() {
                return Object.keys(this.container)
            }
            values() {
                return Object.values(this.container)
            }
            keyValues() {
                return Object.entries(this.container)
            }
            size() {
                return this.keys().length
            }
            isEmpty() {
                return this.size() === 0
            }
            clear() {
                this.container = {}
            }

            forEach(fn) {
                const keys = this.keys()

                keys.forEach(item => fn(item, this.container[item]))
            }
        }

        const dic = new Dictionary();
        dic.set(1, "a");
        dic.set(2, "b");
        dic.set(3, "c");
        dic.set(4, "d");
        dic.set(5, "e");
        console.log(dic.hasKey(1));
        dic.remove(2);
        console.log(dic.get(3));
        console.log(dic.keyValues());
        console.log(dic.keys());
        dic.forEach((key, val) => {
            console.log(`key:${key} val:${val}`);

        })

```

### 4.3 哈希表

![image.png](C:\Users\T540P\Desktop\img (2)\16.png)



 散列表的实现，拿获取值来说。它需要我们提供一个哈希哈数处理我们的key。使其能够快速定位到我们存储数据的存储单元。





这里我们会介绍两种哈希函数，当然好理解的有缺陷，不好理解的最好用。 



#### djb2HashCode(目前最好用的哈希函数)

```
      function djb2HashCode(key) {
            const tableKey = this.toStrFn(key);
            let hash = 5381;
            for (let i = 0; i < tableKey.length; i++) {
                hash = (hash * 33) + tableKey.charCodeAt(i);
            }
            return hash % 1013;
        }

```

#### loseloseHashCode(好理解，它只是将字符串的ascii码与37取余)

```
        function loseloseHashCode(key) {
            if (typeof key === 'number') {
                return key;
            }
            let hash = 0;
            for (let i = 0; i < key.length; i++) {
                hash += tableKey.charCodeAt(i);
            }
            return hash % 37;
        }

```

#### 哈希表的基本实现

```
 class HashTable {
            constructor() {
                this.table = {}
            }

            // 要使用的散列函数
            _loseloseHashCode(key) {
                if (typeof key === "number") {
                    return key
                } else {
                    let hash = 0;
                    for (let i = 0; i < key.length; i++) {
                        hash = hash + key.charCodeAt(i);
                    }
                    return hash % 37;
                }
            }
            put(key, value) {
                if (key != null && value != null) {
                    let position = this._loseloseHashCode(key)
                    this.table[position] = value
                }
            }
            get(key) {
                let position = this._loseloseHashCode(key)
                if (this.table[position]) {
                    return this.table[position]
                } else {
                    return undefined
                }
            }
            remove(key) {
                let position = this._loseloseHashCode(key)
                if (this.table[position]) {
                    delete this.table[position]
                    return true
                } else {
                    return false
                }
            }
        }

```

#### hash表完善之分离链接

![image.png](C:\Users\T540P\Desktop\img (2)\17.png)

如上丑图，键key1key2经过loseloseHashCode处理之后定位到的资源空间是同一块，为了防止数据覆盖的问题，我们将使用链表存放它们。虽然这里在链表中查找key1或key2时还是使用了线性查找。但是在这里也是没有法子的我们只能牺牲一下。不过注意的是我们这是在链表中保存的不止是val了。为了方便定位之后的线性查询我们要连key，val一块存在链表中。



**实现**

先拿过一个单链表来

```
        // 节点类
        class LNode {
            constructor(value) {
                this._value = value
                this._next = null //指针域
            }
        }

        //单链表类
        class LinkList {
            constructor() {
                this._head = null //头节点
                this._count = 0
            }
            push(value) {
                const node = new LNode(value)
                let current = this._head

                if (current === null) {
                    this._head = node
                } else {
                    // 不是空，顺着链条向下找,最后一个节点的指针域为空
                    while (current._next) {
                        current = current._next
                    }
                    current._next = node
                }

                this._count++
            }

            // 移出指定位置的节点
            removeAt(index) {
                if (!(index >= 0 && index < this._count)) return undefined
                let current = this._head
                if (index === 0) {
                    this._head = current._next
                }
                let previous;
                for (let i = 0; i < index - 1; i++) {
                    current = current._next
                }
                previous = current //指向要删除节点的前一个
                current = current._next //指向当前要删除节点
                previous._next = current._next

                this._count--;
                return current._value


            }

            // 获取指定位置的节点
            getElementAt(index) {
                if (!(index >= 0 && index < this._count)) return undefined
                let current = this._head
                for (let i = 0; i < index; i++) {
                    current = current._next
                }
                return current

            }

            // 在任意位置插入
            insert(value, index) {
                if (!(index >= 0 && index < this._count)) return undefined

                const node = new LNode(value)
                    // index==0
                if (index === 0) {
                    let current = this._head
                    this._head = node
                    this._head._next = current
                } else {
                    // 还是先找要操作的前一位置
                    let pre = this.getElementAt(index - 1)
                    let current = pre._next

                    pre._next = node
                    node._next = current

                }
                this._count++;

            }

            //返回指定节点元素的位置
            indexOf(value) {
                let current = this._head
                    //遍历一下链表即可
                for (let i = 0; i < this._count && current != null; i++) {
                    if (current._value === value) {
                        return i
                    } else {
                        current = current._next
                    }
                }
            }

            // 移出一个指定元素的节点
            remove(value) {
                let index = this.indexOf(value)
                this.removeAt(index)
            }

            //链表长度
            size() {
                return this._count
            }

            // 判空
            isEmpty() {
                return this.size === 0
            }

        }

```

改造哈希表,在借一个类用来存数据的key和value

```
  class Node {
            constructor(key, value) {
                this.key = key
                this.value = value
            }
        }
        class HashTable {
            constructor() {
                this.table = {}
            }

            // 要使用的散列函数
            _loseloseHashCode(key) {
                if (typeof key === "number") {
                    return key
                } else {
                    let hash = 0;
                    for (let i = 0; i < key.length; i++) {
                        hash = hash + key.charCodeAt(i);
                    }
                    return hash % 37;
                }
            }
            put(key, value) {
                if (key != null && value != null) {
                    let position = this._loseloseHashCode(key)
                        // 事先判断一下此位置是否有数据
                    if (!this.table[position]) {
                        this.table[position] = new LinkList()
                    }
                    this.table[position].push(new Node(key, value))
                }
            }
            get(key) {
                let position = this._loseloseHashCode(key)
                if (this.table[position]) {

                    let current = this.table[position].getHead()
                    while (current) {
                        if (current._value.key === key) {
                            return current._value.value
                        }
                        current = current.next
                    }
                    //没找到
                    return undefined
                } else {
                    return undefined
                }
            }
            remove(key) {
                let position = this._loseloseHashCode(key)
                if (this.table[position]) {
                    let current = this.table[position].getHead()

                    while (current) {
                        if (current._value.key === key) {
                            this.table[position].remove(current._value)

                            // 删除完如此时链表空了则删除它
                            if (this.table[position].isEmpty()) {
                                delete this.table[position]
                            }
                            return true
                        }
                        current = current._next
                    }
                    // 在链表中没有找到
                    return false

                } else {
                    return false
                }
            }
        }

        const h = new HashTable()
        h.put('name', 'gongxiaobai')
        h.put('name', 'zhangsan')
        h.put('age', '18')
        h.remove('age')
        console.log(h)
        console.log(h.get('name'))

```

如上的测试代码，用两个key一样的测试一下

![image.png](C:\Users\T540P\Desktop\img (2)\18)

#### hash表完善之线性探查

![image.png](C:\Users\T540P\Desktop\img (2)\19.png)

这个比分离链表还要简单一些，它是key定位到15的位置时发现为空就把它的信息节点保存到这，key也是定位15的，但是它来的晚一看已经被人占了。就向下找，找到一个空地就把自己的信息节点保存下来。

信息节点中的东西还是key和val。（方便查询）

逻辑实现还是很顺的，只不过有一个新的点要考虑。就是在节点删除的时候，比如上图我把key1删掉了。那么key2就会很尴尬。因为我们定位都是定位到key1的位置的，一判断key1的位置是空那我们下面实现的get和remove还怎么玩。我们连key2的信息都拿不到。因此在数据移出的时候我们要对它下面的元素位置进行修复(难点)



这里的难点就是移出节点还得修复

其实仔细想一下也不能，也就是把下面的经过哈希函数处理之后key相同的那些东西往上移动位置。

具体什么意思呢？就是这个线性探查首先是个数组一样，如上图左边的key是从上往下一次增大的（或者相等）。移出一个节点之后，我们要看看下面是否有与当前key的哈希值相同或者小于它的，有则需要向上一个坑一个坑的移动

```
  class Node {
            constructor(key, val) {
                this.key = key
                this.val = val
            }
        }
        class LineHashTable {
            constructor() {
                this.table = {}
            }

            // 先创建散列函数
            _loseloseHashCode(key) {
                if (typeof key === "number") {
                    return key
                } else {
                    let hash = 0
                    for (let i = 0; i < key.length; i++) {
                        hash = hash + key.charCodeAt(i)
                    }
                    return hash % 37
                }
            }

            // 新增一条到散列表
            put(key, val) {
                    if (key != null && val != null) {
                        const position = this._loseloseHashCode(key);
                        if (this.table[position] == null) {
                            // 为空放入节点
                            this.table[position] = new Node(key, val);
                        } else {
                            // 向下找空的储存空间
                            let index = position + 1;
                            while (this.table[index]) {
                                index++;
                            }
                            this.table[index] = new Node(key, val)
                        }
                        return true
                    }
                    return false
                }
                // 取值
            get(key) {
                let position = this._loseloseHashCode(key)

                //    先直接到lost函数所能快速定位的地方
                if (this.table[position] != null) {
                    // 再判是不是我们要的值
                    if (this.table[position].key === key) {
                        return this.table[position].val
                    }
                    // 不是则需要在此地的基础上向下寻找了
                    let index = position + 1
                    while (this.table[index] != null && this.table[index].key != key) {
                        index++
                    }
                    // 上面出来了有两种可能
                    // 1.找到目标
                    // 2.有一个空的地址
                    if (this.table[index].key === key) {
                        return this.table[index].val
                    } else {
                        return undefined
                    }

                }
                return undefined
            }

            // 移出值
            remove(key) {
                const position = this._loseloseHashCode(key);
                if (this.table[position] != null) {
                    // 判此时这个位置上的使我们要的吗
                    if (this.table[position].key === key) {
                        delete this.table[position]
                            // 修复下面的位置
                        this._move(key, position)
                        return true
                    } else {
                        let index = position + 1
                        while (this.table[index] != null && this.table[index].key !== key) {
                            index++
                        }
                        if (this.table[index].key === key) {
                            delete this.table[index]

                            // 修复下面的位置
                            this._move(key, index)
                            return true
                        } else {
                            return false
                        }
                    }

                }
                return false

            }

            //难点
            _move(key, removedPosition) {
                let hash = this._loseloseHashCode(key)
                let index = removedPosition + 1
                while (this.table[index] != null) {

                    let posHash = this._loseloseHashCode(this.table[index].key)
                        // 如果当前元素的 hash 值小于或等于原始的 hash 值（行{5}）或者当前元素的 hash 值小于或等于 removedPosition（也就是上一个被移除 key 的 hash 值），表示我们需要将当前元素移动至 removedPosition 的位置
                    if (posHash <= hash || posHash <= removedPosition) {
                        this.table[removedPosition] = this.table[index]
                        delete this.table[index]
                        removedPosition = index
                    }
                    index++
                }
            }
        }
        const h = new LineHashTable()
        h.put('name', 'gongxiaobai')
        h.put('name', 'zhangsan')
        h.put('age', '18')
        h.remove('age')
        console.log(h)
        console.log(h.get('name'))

```

![image.png](C:\Users\T540P\Desktop\img (2)\20.png)





### 参考书籍：

王道考研数据结构

严奶奶的那本（数据结构(C语言版) 第2版 (严蔚敏等)）

学习js数据结构与算法

### 写到最后

[小白原来的笔记链接](https://blog.csdn.net/qq_41086511/category_9593561.html)（有一些错误没有进行更改）

星光不问赶路人，时光不负有心人
期待着我们的下一次邂逅

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/296edd3c67d648aca0eae06bb9484af0~tplv-k3u1fbpfcp-zoom-1.image)

# 第四期：数据结构（中）——来实现二叉搜索树、二叉堆与图

## 一、 二叉搜索树

树的实现与其相关操作其实都很简单，它的核心就是依靠递归嘛

至于我们为啥上来就直接实现二叉搜索树，而不是别的什么树呢？

首先这树这种数据结构中，其二叉树是最为重要的（也即度小于等于2）。

但是呢？在二叉树中，二叉搜索树又是极为重要且经典的数据结构

**why？**

![1596879237386](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596879237386.png)

那什么是二叉搜索树呢？

![1596879307498](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596879307498.png)

即它在二叉树的基础上又做了一个规定， 即只允许你在左侧节点存（比父节点）小的值，在右侧节点存储（比父节点）大的值。 左小右大嘛方便后面的搜索



在下面我们将实现以下方法

- add（key）向树中添加节点
- 遍历（中序先序后序只是输出key的位置不同而已，以中序为例）
- min（）取最小值
- max（）取最大值
- search（key）判数组是否存在某值
- remove（key）删除树中某节点

### 实现

#### 1. 添加节点

```js
add(key) {
            const node = new TNode(key)

            // 下面两种情况，树为空或不空
            if (this.root === null) {
                this.root = node
            }
            // 不为空得找地方，另写一个方法
            else {
                this._addNode(this.root, node)
            }
        }
        _addNode(node, newNode) {
            // 首先跟根节点比较大小以判断一会往左方还是往右方
            // 放右边去吧
            if (newNode.key > node.key) {
                if (node.right === null) {
                    node.right = newNode
                } else {
                    this._addNode(node.right, newNode)
                }
            }
            // 放左边去吧
            else {
                if (node.left === null) {
                    node.left = newNode
                } else {
                    this._addNode(node.left, newNode)
                }
            }
        }
```



#### 2. 遍历（前中后序遍历只在于打印语句代码的先后顺序）

```js
// 中序遍历
        //如果你对递归理解的不是很好，小白这里简单解释一下
        // 首先这句this._middleTraversal(node.left)，即进入函数看有无左孩子，有接着往左边跑，什么时候到打印语句呢？肯定此时已经到了最左边，开始之心函数下面的语句，打印就不用说了，打印完了再看它有无右孩子
        // 接着这个递归栈开始弹栈，到上一个左孩子的父节点，然后打印看有无右孩子
        //就这样随着弹栈，随着打印，随着判断有孩子，有有孩子就进去处理
        //右的方式同理
        _middleTraversal(node) {
                if (node != null) {
                    // 去找左边
                    this._middleTraversal(node.left)

                    // 左到头了，开始打印
                    console.log(node.key)

                    this._middleTraversal(node.right)

                }
            }
            // 对外暴露这个中序遍历的方法，以为上面的还有传入根节点
        middleTraversal() {
            this._middleTraversal(this.root)
        }

```



#### 3. 取最大、取最小值

```js
// 我们都清楚一般使用递归的也可使用循环进行改造
        // 递归简单好理解，但是性能差
        // 循环不好理解，但是性能好(这里的都比较简单)
        // 下面，我min用循环，max用递归
        min() {
            return this._minNode(this.root).key
        }

        //根据二叉搜索树的特性，最小值就是最左边的呗
        _minNode(node) {
            while (node != null && node.left != null) {
                node = node.left
            }
            return node
        }

        max() {
            return this._maxNode(this.root).key
        }

        // 在最右边呗
        _maxNode(node) {
            if (node.right === null) {
                return node
            } else {
                return this._maxNode(node.right)
            }

        }

```



#### 4. 搜索指定节点

```js
       isKey(key) {
            return this._isKey(this.root, key)
        }
        _isKey(node, key) {
            if (node === null) {
                return false
            }
            // 左边
            if (node.key > key) {
                return this._isKey(node.left)
            }
            // 右边
            else if (node.key < key) {
                return this._isKey(node.right)
            }
            // 相等
            else if (node.key === key) {
                return true
            } else {
                return false
            }
        }
```



#### 5. 移出节点(本章难点)

这段代码的难点是在于返回值有一个易错点

**错误示例**

容易认为像这样

` // 情况二
                if (node.left != null && node.right === null) {
                    node = node.left
                    return true
                }`

直接node=node.left，就认为它们之间的指针关系连接好了，但其实并没有。其父节点仍然是指向的原来的子节点，即这棵树你根本没有做任何改变

为啥呢？因为你这样写是拿不到它的父节点的，它父节点指向的还是原来的它子节点那块地址

你可能又会说我不是改变node的值了么？

首先node只是个变量，它原先指的是一个对象的，你现在又让它指向一个新的对象

可是其父节点中指针域可不是指的你node啊，它指的你node指向的那块地址。此时你node又指向了新的地址，其父节点可不会跟着变化啊（小白还是纯小白时犯下的错误，公开处刑？害，谁让那时自己基础差啊，改了得有2-3天）

```js
 remove(key) {
            return this._remove(this.root, key)
        }

        // 这里有三种情况
        // 1. 叶子节点，直接干掉即可
        // 2. 有一个孩子，那么将它的孩子作为继承人就行了
        // 3. 两孩子就比较难受了，得找一个和它比较像的吧。有两个，它左子树的右叶子和它右子树的左叶子。这里我们将它的继承者定为它右子树的左叶子。
        _remove(node, key) {
            if (node.key > key) {
                return this._remove(node.left, key)

            } else if (node.key < key) {
                return this._remove(node.right, key)

            }
            // 找到了开始删除
            else if (node.key === key) {
                // 情况一
                if (node.left === null && node.right == null) {
                    node = null
                    return true
                }
                // 情况二
                if (node.left != null && node.right === null) {
                    node = node.left
                    return true
                }
                if (node.left === null && node.right != null) {

                    node = node.right
                    return true
                }

                // 情况三
                const rightTree = node.right
                const currentKey = this._minNode(rightTree).key
                node.key = currentKey

                this._remove(node.right, currentKey)
                return true

            } else {
                return false
            }
        }
    }
```

**正确代码**

```js
        remove(key) {
            return this.root = this._remove(this.root, key)
        }

        // 这里有三种情况
        // 1. 叶子节点，直接干掉即可
        // 2. 有一个孩子，那么将它的孩子作为继承人就行了
        // 3. 两孩子就比较难受了，得找一个和它比较像的吧。有两个，它左子树的右叶子和它右子树的左叶子。这里我们将它的继承者定为它右子树的左叶子。
        _remove(node, key) {
            if (node.key > key) {
                node.left = this._remove(node.left, key)
                return node
            } else if (node.key < key) {
                node.right = this._remove(node.right, key)
                return node
            }
            // 找到了开始删除
            else if (node.key === key) {
                // 情况一
                if (node.left === null && node.right == null) {
                    node = null
                    return node
                }
                // 情况二
                if (node.left != null && node.right === null) {
                    node = node.left
                    return node
                }
                if (node.left === null && node.right != null) {

                    node = node.right
                    return node
                }

                // 情况三
                const rightTree = node.right
                const currentKey = this._minNode(rightTree).key
                node.key = currentKey

                node.right = this._remove(node.right, currentKey)
                return node

            } else {
                return false
            }
        }
    }

```

**部分测试代码**

```js
  tree.add(6)
    tree.add(7)
    tree.add(4)
    tree.add(2)
    tree.add(10)
    tree.middleTraversal()
    console.log(tree.min())
    console.log(tree.max())
    console.log(tree.remove(6))

    console.log(tree)
    console.log(tree.isKey(11))
```

![1596895412647](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596895412647.png)

## 二、 二叉堆

终于到了一个比较来说实现不是那么常规的数据结构的实现了

首先来了解一下什么是二叉堆？

二叉堆的本质是一个完全二叉树，且其又有最大堆最小堆之分

最小堆：任何一个父节点的值都要小于它左右孩子的值

![1596933845726](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596933845726.png)

最大堆与最小堆相反

### 来看二叉堆的实现吧（原理一下，这里我们以最小堆为例）

我们接下来我实现以下功能：

- insert（val）像堆中插入新数据
- extract（）剔除最小值（最小堆），最大堆就剔除最大值
- findMin（） 返回最小者，最大堆中就findMax返回最大值呗

 **前提：**
我们要知道储存一棵二叉树一般有两种方式，一个是“指针”的形式即保存数据之间的联系。
第二种形式即使用数组，我们可以事先给树编写序号，利用数组的索引位置一一对应。如下图
![1596933945276](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596933945276.png)
这时我们就得需要知道一些东西 

**在数组中给我们一个数据的位置，我们如何拿到它的父、子节点？**
通过一些规律观察我们可以有以下结论。
数组中如果给定一已存储了节点元素个位置index，那么

- 它的左子节点位置是 2 * index + 1；
- 它的右子节点位置是 2 * index + 2；
- 它的父节点位置是（index -1）/ 2（向下取整，根节点除外）。

**工具函数**

```js
 class MinHeap {
        constructor() {
            this.data = []
        }

        //先写三个工具函数

        // 拿左孩子
        _getLeftIndex(index) {
            return 2 * index + 1
        }

        // 拿右孩子
        _getRightIndex(index) {
            return 2 * index + 2
        }

        //拿父节点
        _getParentIndex(index) {
            if (index === 0) {
                return undefined
            } else {
                return Math.floor((index - 1) / 2)
            }
        }
 }
```



#### insert：插入数据

实现insert方法的核心就是它里面的上移操作。
什么上移及怎么上移呢？
看图 (图片是以前画的，其水印是我原来在某c开头博客做笔记时上传的，下面是我又截下来的)

![1596941599092](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596941599092.png)

 新来一个节点2，要加入堆中，开始加入堆底。即放到节点3的右孩子位置上 

![1596941736822](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596941736822.png)

 这是因为二叉堆的特性，最小堆父节点数据是要小于它每个子节点的。现在不符合这一特性了，即节点2要进行上移。怎么上移呢，它先和自己的父节点进行数据的比较。若比其父节点数值小。则进行位置交换 

![1596941757572](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596941757572.png)

 交换完成 

![1596941776664](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596941776664.png)

**实现**

```js
        insert(value) {

            this.data.push(value) //此时相当于新来的在树的最后了
            this._upHead(this.data.length - 1) //进行上移

        }
        // 上移
        _upHead(index) {
            // 拿其父节点
            let parent = this._getParentIndex(index)

            while (index > 0 && (this.data[index] < this.data[parent])) {
                // 交换
                this._swap(this.data, parent, index)
                index = parent
                parent = this._getParentIndex(index)
            }
        }
        // 交换
        _swap(arr, a, b) {
            [arr[b], arr[a]] = [arr[a], arr[b]]
        }
```

#### extract：剔除堆顶

extract方法的作用是剔除堆顶。
extract方法的核心是堆化，先来看看堆化的思路吧。 

如下图我们要剔除堆顶，不能直接剔除就完事了吧。。。我们还要保持它的堆结构呢，怎么保持呢？ 

![1596941869986](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596941869986.png)

 首先让这个堆顶节点1与它的子节点比较，小于它的子节点（废话嘛）。交换两者位置 

![1596941904774](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596941904774.png)

交换完成之后，再与它的子节点比较。这时就出现了一点问题。如果是和节点7交换，那么我们直接pop掉即可，和6交换我们要怎么办呢？去data里面去找到吗？这显然不是我们不需要的。 

![1596941961377](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596941961377.png)



 **来再换一种方法吧** 

 首先我们就先把堆顶和堆底节点互换，然后把换完的新堆底扔出去 

![1596942006162](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596942006162.png)

 这时新堆顶是7，它要下移。则有子节点比较。交换位置 

![1596942026117](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596942026117.png)

 接着比较，交换位置 

![1596942042933](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596942042933.png)

 再换，大功告成 

![1596942085084](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596942085084.png)

```js
       extract() {
            //空堆
            if (this.data.length === 0) {
                return false
            }
            if (this.data.length === 1) {
                return this.data.pop()
            }
            // 堆中有多值
            let current = this.data[0] //要删除的

            // 交换
            this._swap(this.data, 0, this.data.length - 1)
                //移出
            this.data.pop()

            // 下移
            this._sinkDown(0)
            return current

        }

        // 堆化（下移）
        _sinkDown(index) {
            let current = index
            let left = this._getLeftIndex(index)
            let right = this._getRightIndex(index)
            let size = this.data.length

            //与左孩子比较
            if (this.data[current] > this.data[left] && left < size) {

                current = left
            }
            if (this.data[current] > this.data[right] && left < size) {

                current = right
            }

            //current发生了变动，开始进行交换及其递归处理，没有发生变动则说明此时已经是堆化的结构了
            if (index != current) {
                this._swap(this.data, index, current);
                this._sinkDown(current)
            }

        }
```

#### findMin :返最小值（即堆顶）

```js
        findMin() {
            return this.data.length === 0 ? undefined : this.data[0]
        }
```

部分测试代码

```js
 heap.insert(4)
    heap.insert(5)
    heap.insert(1)
    heap.insert(2)
    heap.insert(3)

    console.log(heap)
```

![1596941494743](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596941494743.png)

```js
    heap.insert(4)
    heap.insert(5)
    heap.insert(1)
    heap.insert(2)
    heap.insert(3)

    heap.extract()
    console.log(heap)
```

![1596941536672](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596941536672.png)

## 三、图（以最简单的无方无权图为例）



**这可能是你见过最简单的图的实现方法**



![1596976092788](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596976092788.png)

### 3.1 图的表示

来简单复习一下吧

#### 邻接矩阵

采用一个二维矩阵

如图：（额找的这个图不太好，咋都有三个边啊）

![1596976352004](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596976352004.png)

顶点的存储方式好说，数组就可以。便就用这么一个矩阵，ab之间右边则记为1

再来简单说一下它的缺点：对于一个边极少（矩阵为稀疏矩阵）浪费空间

#### 邻接表

![1596976855095](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596976855095.png)

邻接表可借助如图一个链表的方式存储每个顶点的表

也来简单说一下它的缺点：对于有向图的入边表示不了

### 3.2 图的实现

我们这里不适用链表表示边的情况了，为了简单。我们就使用一个对象

如顶点A相邻的顶点有B，C，D

我们就这样表示{"A":["B","C","D"]}

图的表示才有邻接表

```js
 class Graph {
        constructor() {
            this.vertexes = []//顶点
            this.edges = {}//记录边
            this.statu = {}//顶点状态
        }
 }
```

#### 加入顶点

```js
  addVertexe(v) {
            this.vertexes.push(v)
            this.edges[v] = []
        }
```

#### 加入边

```js
   addEdges(v1, v2) {
            this.edges[v1].push(v2)
            this.edges[v2].push(v1)
        }
```

### 3.3 图的遍历

记录状态

```js
 _initStatu() {
            this.vertexes.forEach(item => {
                this.statu[item] = 1
            })
        }
```

bfs需要借助队列，把上次写好的队列拿过来

```js
 class Queue {
        constructor() {
            this._data = {}
            this._count = 0
            this._first = 0 //队头指针
        }
        isEmpty() {
            return this._count === this._first
        }
        enqueue(value) {
            this._data[this._count++] = value
        }
        dequeue() {
            if (this.isEmpty()) {
                return undefined
            }
            let res = this._data[this._first]
            delete this._data[this._first]
            this._first++;
            return res

        }
        peek() {
            if (this.isEmpty()) {
                return undefined
            }
            return this._data[this._first]
        }
        size() {
            return this._count - this._first
        }
        clean() {
            this._data = {}
            this._count = 0
            this._first = 0
        }
    }
```

#### 广度优先搜索

```js
 bfs(v, fn) {
            // 初始化状态
            this._initStatu()
            const q = new Queue()
            q.enqueue(v)

            while (!q.isEmpty()) {
                let current = q.dequeue()

                // 将当前顶点状态设为2
                this.statu[current] = 2

                // 取与当前顶点相连的入队
                this.edges[current].forEach(item => {
                    if (this.statu[item] == 1) {
                        this.statu[item] = 2
                        q.enqueue(item)
                    }
                })

                // 访问出队的顶点（即操作它）
                fn(current)
                this.statu[current] = 3
            }
        }
```

测试代码

```js
 const g = new Graph();
    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'].forEach(item => g.addVertexe(item))

    g.addEdges('A', 'B')
    g.addEdges('A', 'C')
    g.addEdges('A', 'D')
    g.addEdges('C', 'D')
    g.addEdges('C', 'G')
    g.addEdges('D', 'G')
    g.addEdges('D', 'H')
    g.addEdges('B', 'E')
    g.addEdges('B', 'F')
    g.addEdges('E', 'I')
    console.log(g)
    g.bfs('A', function(v) {
            console.log(v)
        })
```



![1596975669326](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596975669326.png)

#### 深度优先搜索

```js
  dfs(v, fn) {
            // 初始化状态
            this._initStatu()
            this._dfsVisit(v, fn)

        }
        _dfsVisit(v, fn) {
            this.statu[v] = 2
            fn(v)

            // 拿与其相邻的顶点
            this.edges[v].forEach(item => {
                if (this.statu[item] === 1) {
                    this._dfsVisit(item, fn)
                }
            })
            this.statu[v] = 3
        }
    }
```

测试代码

```js
 const g = new Graph();
    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'].forEach(item => g.addVertexe(item))

    g.addEdges('A', 'B')
    g.addEdges('A', 'C')
    g.addEdges('A', 'D')
    g.addEdges('C', 'D')
    g.addEdges('C', 'G')
    g.addEdges('D', 'G')
    g.addEdges('D', 'H')
    g.addEdges('B', 'E')
    g.addEdges('B', 'F')
    g.addEdges('E', 'I')
    console.log(g)
    g.dfs('A', function(v) {
            console.log(v)
        })
```



![1596975621421](C:\Users\T540P\AppData\Roaming\Typora\typora-user-images\1596975621421.png)